---
title: "Görselleştirme"
format:
  html:
    toc: true
    toc-depth: 2
    number-sections: true
    code-fold: false
    df-print: paged
    sidebar: haftalar
---

Bu derste kullanacağımız midiPISA veri seti;

öğrenci id (OGRENCIID), sınıf düzeyi (SINIF), cinsiyet (CINSIYET), anne eğitim düzeyi (Anne_Egitim), baba eğitim düzeyi (Baba_Egitim), okumaktan zevk alma (OKUMA_ZEVK), ST097Q01TA, ST097Q02TA, ST097Q03TA, ST097Q04TA, ST097Q05TA, okuma puanı olası değer 1 (ODOKUMA1), okuma puanı olası değer 2 (ODOKUMA2), okuma puanı olası değer 3 (ODOKUMA3), okuma puanı olası değer 4 (ODOKUMA4), okuma puanı olası değer 5 (ODOKUMA5) değişkenleri olmak üzere toplam 16 değişkenden oluşmaktadır. [Veri Seti](data/midiPISA.rda)

```{r}
load("data/midiPISA.rda")
```

önce veriyi inceleyelim

```{r}
library(tidyverse)
library(dplyr)
dplyr::glimpse(midiPISA)
```

Anne_Eğitim kategorilerine bakalım

```{r}
midiPISA |> 
  distinct(Anne_Egitim )

```

Ortaya çıkan tabloyu incelediğimizde aslında **8 olası** değeri olduğunu öğreniyoruz

Baba_Eğitim kategorilerine bakalım

```{r}
midiPISA |> 
  distinct(Baba_Egitim )
```

İki kategorik değişkenin (örneğin burada olduğu gibi) her bir düzey kombinasyonuna düşen gözlem sayılarını göstermek için yaygın kullanılan bir yol **“kontenjans tablosu” (contingency table)** oluşturmaktır.

Bir kontenjans tablosu oluşturmak için üç adım gerekir:

1.  Gözlem sayılarını saymak için `count()` fonksiyonunu kullanmak

2.  İlgilendiğiniz değişkenleri `count()` fonksiyonu içine belirtmek.

```{r}
midiPISA |> 
  count(Anne_Egitim, Baba_Egitim)
```

bu tabloyu geniş hale getirelim

ama önce spss etiketlerini düzeltelim

```{r}
library(sjlabelled)
midiPISA <- midiPISA %>% mutate_if(is_labelled, as_factor)
# Faktor degiskenlere duzey atama amacıyla yazılan fonksiyon
levelsnames <- function(x){
  levels(x) <- names(attr(x,"labels"))
  x
}
# Yazılan fonkisyonun faktor degiskenlere uygulanması
midiPISA <-mutate_if(midiPISA,is.factor, levelsnames)
```

uzun veriyi geniş hale getirmek için `pivot_wider`

```{r}
midiPISA |> 
  count(Anne_Egitim, Baba_Egitim) |>
  pivot_wider(names_from = Anne_Egitim, values_from = n)
```

Bazı düzeylerde çok az sayıda gözlem olduğunu ortaya koydu. Analizi basitleştirmek için bu tür düzeyleri veri setinden çıkarmak genellikle faydalıdır.

R’da bu işlem iki adım gerektirir:

1.  Çok az gözleme sahip düzeyleri içeren satırları **filter()** ile çıkarmak

2.  Bu düzeyleri değişkenden tamamen kaldırmak için **droplevels()** fonksiyonunu kullanmak

`droplevels()` fonksiyonunu, sıfır gözleme sahip düzeyleri bir değişkenden temizlemek için kullanırız.

```{r}
midiPISA_filtered <- midiPISA %>% 
  filter(!is.na(Anne_Egitim))%>%
  filter(!is.na(Baba_Egitim))%>%
  droplevels()

```

## Çubuk Grafiği

çoğu zaman kategorik değişkenleri **grafiksel olarak** göstermek daha tablo olarak sunmaktan anlamlıdır.

`geom_bar()` fonksiyonuna `position = "dodge"` argümanını eklemek, grafiğin **yan yana çubuk grafik** (yani yığılmamış) olmasını sağlar.

Bu grafikleri oluşturmak için şu adımları izleyin:

1.  **ggplot2** paketini yükleyin.

2.  X ekseninde **Anne_Egitim** olacak şekilde, çubukları karakterlerin **CINSIYET** değişkenine göre doldurarak (fill) yan yana bir çubuk grafik oluşturun.

3.  X ekseninde **CINSIYET** olacak şekilde, çubukları karakterlerin **align** değişkenine göre doldurarak ikinci yan yana çubuk grafiği oluşturun.

```{r}
ggplot(midiPISA_filtered , aes(x = Anne_Egitim  , fill = CINSIYET  )) + 
  geom_bar() 

# yan yana 
ggplot(midiPISA_filtered , aes(x = Anne_Egitim  , fill = CINSIYET  )) + 
  geom_bar(position = "dodge")
```

Pek çok görselleştirmede, grafikteki **eksen etiketlerini** değiştirmek isteyebilirsiniz. Buradaki örnekte “CINSIYET” ve “Anne_Egitim” etiketleri biraz daha açıklayıcı hale getirilebilir.

Bir `ggplot()` grafiğinin etiketlerini değiştirmek için grafiğe `+ labs()` katmanı eklenir. Bu katmanda **x**, **y**, ve **fill** etiketlerini, ayrıca grafiğin **başlığını** belirleyebilirsiniz.

```{r}
ggplot(midiPISA_filtered , aes(x = Anne_Egitim  , fill = CINSIYET  )) + 
  geom_bar(position = "dodge") + 
   labs(x = "Eğitim Düzeyi", 
       fill = "CINSIYET", 
       y = "Sayi") 
```

## Sayılardan Oranlara

Bazen ham gözlem sayıları yararlı olsa da çoğu zaman **oranlar** daha ilgi çekicidir. Bu oranları kafamızdan hesaplamaya çalışabiliriz ama R ile açıkça hesaplamak çok daha kolaydır.

Her kategoriye düşen gözlemlerin **toplam içindeki oranlarını** görmek istiyorsak, önceki tablomuzu biraz değiştirmemiz gerekir. Bunun için her bir **cinsiyet** ve **sınıf**kombinasyonunda gözlemlerin toplam gözlemler içindeki oranını hesaplayan bir sütun eklemeliyiz.

Her düzeydeki gözlemleri saydıktan sonra, `mutate()` fonksiyonu ile bu düzeylere düşen gözlemlerin oranını hesaplarız. Bu oranları **prop** adlı yeni bir değişkene kaydederiz.

Daha önce olduğu gibi, uzun tabloyu geniş tabloya dönüştürürüz (`pivot_wider()`). Ancak burada tabloya eklenmiş **ekstra bir sütun (n)** vardır ve biz bu sütunu tabloda istemiyoruz. Bu nedenle `id_cols` argümanına, tabloya dahil etmek istediğimiz değişkenlerin isimlerini bir vektör olarak belirtmemiz gerekir. Böylece `names_from` ve `values_from` için kullanılan değişkenler dışında kalan sütunlar korunmuş olur.

```{r}
midiPISA |>
  count(CINSIYET, SINIF) |>
  group_by(SINIF) |> 
  mutate(prop = n / sum(n)) |> 
  pivot_wider(id_cols = CINSIYET, 
              names_from = SINIF, values_from = prop)
```

## Koşullu Oranlar

Değişkenler arasındaki sistematik ilişkilerle ilgileniyorsak, **koşullu oranlara** bakmamız gerekir.

Bu koşullu oranların tablosunu oluşturmak için, oranları hesaplamadan önce bir **gruplama değişkeni** belirtmemiz gerekir. Bu gruplamayı, `group_by()` fonksiyonu ile yaparız.

👉 **Satırlara göre koşullandırma (yani satırların toplamı = 1).**

```{r}
ggplot(midiPISA, aes(x = CINSIYET, fill = SINIF)) +
  geom_bar(position = "fill") 
```

```{r}
ggplot(midiPISA, aes(fill = CINSIYET,  x= SINIF)) +
  geom_bar(position = "fill") 
```

## Tek Değişkenin Dağılımı

Tek bir değişken (örneğin CINSIYET) için frekans tablosu oluşturmak için yine `count()` fonksiyonunu kullanabiliriz. Bu daha basit tabloyu düşünmenin bir yolu da şudur: Orijinal iki yönlü tabloda (iki kategorik değişkenle) her bir SINIF düzeyindeki hücreleri toplayarak özetledik. Diğer değişkenler üzerinden toplama yaptığımız için bu özetleme bazen marjinal dağılım (marginal distribution) olarak adlandırılır.

```{r}
midiPISA |> 
  count(CINSIYET)
```

```{r}
midiPISA |> 
  count(CINSIYET,SINIF) |> 
  pivot_wider(names_from = CINSIYET , values_from = n)
```

## Basit Çubuk Grafik

Basit çubuk grafik oluşturmanın sözdizimi oldukça basittir; bunu dersin başında görmüştük. Bunun için `aes` içinden **fill = align** argümanını çıkarmamız yeterlidir.

-   cinsiyet

```{r}
ggplot(midiPISA, aes(x = CINSIYET)) +
  geom_bar()
```

-   sınıf düzeyi

```{r}

# Yeni sıralamayla çubuk grafik
ggplot(midiPISA, aes(x = SINIF)) +
  geom_bar(fill = "steelblue") +
  labs(title = "Sınıf Düzeylerinin Dağılımı",
       x = "Sınıf",
       y = "Öğrenci Sayısı")
```

## Faceting (Alt Grafikler)

Tek bir değişkenin dağılımını görselleştirmenin başka yararlı bir yolu, onu başka bir değişkenin belirli bir değerine göre koşullandırmaktır. Örneğin yalnızca **10. Sınıf** öğrencileri için **CINSIYET** dağılımını görmek isteyebiliriz.

Bunu yapmak için:

-   Veri setini filtreleyip sadece **SINIF= "10"** olanlarla bir çubuk grafik çizebiliriz,

-   Ya da **faceting** tekniğini kullanabiliriz. Faceting, veriyi bir kategorik değişkenin düzeylerine göre alt gruplara ayırır ve her düzey için ayrı bir grafik oluşturur.

## Facet’li Çubuk Grafikler

`ggplot2`’de faceting uygulamak için grafiğe sadece bir katman daha ekleriz. Bunun için `facet_wrap()` fonksiyonu kullanılır. İçine **tilde (\~)** ve facet yapmak istediğimiz değişkenin adı yazılır (örn. `~`**SINIF**).

Bu, yukarıdaki grafiği oluştur ama bunu **SINIF**değişkenine göre parçala anlamına gelir.

Yüm sınıf düzeyleri için grafikler elde edilir.

```{r}
ggplot(midiPISA, aes(x = CINSIYET)) +
  geom_bar() +
  facet_wrap(~SINIF)
```

## Faceting ve Yığma

Özünde, facet’li grafik dersin başında gördüğümüz **yığılmış çubuk grafiklerin** farklı bir düzenlemesidir.

Facet’ler ya da yığılmış çubuklar:

-   Tek bir değişkenin dağılımını görmek için tek bir facet’e ya da çubuğa,

-   Değişkenler arasındaki ilişkiyi görmek için facet’ler ya da çubuklar arasında karşılaştırma yapmaya olanak tanır.

```{r}
ggplot(midiPISA, aes(x = CINSIYET ,fill = SINIF)) +
  geom_bar() 
```

## Pasta Grafiği

Pasta grafiği, kategorik verileri göstermenin yaygın bir yoludur. Dilimlerin büyüklüğü, o düzeydeki gözlem oranını gösterir.

```{r}
ggplot(midiPISA, aes(x = "", fill = SINIF)) +
  geom_bar(width = 1) +
  coord_polar("y") +
  labs(title = "Sınıf Dağılımı (Pie Chart)", fill = "Sınıf")
```

-   cinsiyete göre

```{r}
ggplot(midiPISA, aes(x = "", fill = SINIF)) +
  geom_bar(width = 1) +
  coord_polar("y") +
  facet_wrap(~CINSIYET) +
  labs(title = "Cinsiyete Göre Sınıf Dağılımı", fill = "Sınıf")

```

-   oranları ekle

```{r}
pie_data <- midiPISA %>%
  count(CINSIYET, SINIF) %>%
  group_by(CINSIYET) %>%
  mutate(prop = n / sum(n),
         label = scales::percent(prop, accuracy = 1))

# Pasta grafik + etiketler
ggplot(pie_data, aes(x = "", y = prop, fill = SINIF)) +
  geom_col(width = 1) +
  coord_polar("y") +
  facet_wrap(~CINSIYET) +
  geom_text(aes(label = label),
            position = position_stack(vjust = 0.5), # dilimin ortasına koy
            color = "white",
            size = 4) +
  labs(title = "Cinsiyete Göre Sınıf Dağılımı",
       fill = "Sınıf",
       x = NULL, y = NULL) +
  theme_void()
```

```{r}
library(dplyr)

pie_data <- midiPISA %>%
  count(SINIF) %>%
  mutate(prop = n / sum(n),
         label = scales::percent(prop, accuracy = 1))

ggplot(pie_data, aes(x = "", y = prop, fill = SINIF)) +
  geom_col(width = 1, color = "white") +
  coord_polar("y") +
  geom_text(aes(label = label),
            position = position_stack(vjust = 0.5),
            color = "white", size = 4) +
  labs(title = "Sınıf Dağılımı (%)", fill = "Sınıf") +
  theme_void()

```

```{r}
library(dplyr)
library(plotly)

# Veri: SINIF değişkenine göre sayılar
pie_data <- midiPISA %>%
  count(SINIF)

# Etkileşimli pie chart
plot_ly(pie_data,
        labels = ~SINIF,
        values = ~n,
        type = "pie",
        textinfo = "label+percent",   # etiket + yüzde
        insidetextorientation = "radial") %>%
  layout(title = "Sınıf Dağılımı (Pie Chart - Plotly)")
```

## Dotplot

Sayısal verileri temsil etmenin en doğrudan yolu **nokta grafiği (dotplot)** kullanmaktır. Burada her bir gözlem, x-eksenindeki uygun değerine yerleştirilen bir nokta ile gösterilir. Benzer değerlere sahip gözlemler, diğerlerinin üstüne yığılır. Nokta grafiğini histogramın bir “kardeşi” gibi düşünebilirsiniz, ancak burada her sütunda kaç gözlem olduğunu tam olarak bilirsiniz, çünkü noktaları tek tek sayabilirsiniz. Önemli bir nokta ise, bu grafik histogramdan çok daha az bilgi kaybı içerir; hatta yalnızca bu grafik verilse bile veri setini neredeyse yeniden oluşturabilirsiniz. Tahmin edebileceğiniz gibi, gözlem sayısı çok arttığında bu grafikleri okumak zorlaşmaya başlar.

Aşağıdaki kod, veri setindeki rasgele seçilmiş 100 kişinin okumaktan alığı zevk için nokta grafiği üretmektedir. Dikkat ederseniz, yalnızca tek bir sayısal değişkenle (ağırlık) ilgilendiğimiz için estetiklerde (aesthetics) yalnızca bu değişken belirtilmiştir. Ayrıca, bu değişken x-estetiği olarak tanımlanmıştır çünkü sayısal bir değişkeni x-ekseninde göstermek “standart”tır. Son olarak, grafiğe noktaları eklemek için **geom_dotplot()** fonksiyonunun kullanıldığını görüyoruz. Bu fonksiyonun **dotsize** adlı isteğe bağlı bir argümanı vardır; bu argüman noktaların ne kadar büyük olacağını belirler (0’a yakın değerler noktaları küçültür, 1’e yakın değerler büyütür).

```{r}
set.seed(100)
midiPISA_filtered %>% sample_n(100) %>% 
ggplot( aes(x = OKUMA_ZEVK  )) +
  geom_dotplot(dotsize = 0.4)
```

Nokta grafiğinde dikkat edersek, y-ekseni biraz kafa karıştırıcıdır çünkü 0.0 ve 1.0 değerlerinin neyi ifade ettiği açık değildir. Bu durum, **ggplot2’nin talihsiz bir sınırlılığıdır**: x-ekseni boyunca gruplama (binning) ve y-ekseni boyunca yığma (stacking) işlemi, anlamlı olmayan bir y-ekseni ile sonuçlanır. Grafik çizim becerilerimiz ilerledikçe, y-ekseni tamamen gizlemeyi ya da noktaların sayısıyla daha uyumlu olacak şekilde ölçeği manuel olarak ayarlamayı tercih edebiliriz.

## Histogram

En yaygın kullanılan grafik türlerinden biri **histogramdır**. Histogram, bu sorunu çözmek için noktaları x-ekseni boyunca kutulara (bin) toplar ve her sütunun yüksekliği, o kutuya düşen gözlem sayısını gösterir. Bu gruplama (binning) nedeniyle veri setini eksiksiz bir şekilde yeniden oluşturmak mümkün değildir; ancak bu yöntem, dağılımın genel şeklini daha net görmemizi sağlar.

Dikkat ederseniz, kodda değişen tek şey **geom_dotplot()** fonksiyonunun **geom_histogram()** ile değiştirilmesidir.

```{r}

midiPISA %>% 
ggplot( aes(x = OKUMA_ZEVK  )) +
  geom_histogram()
```

**Not:** Yukarıdaki kodu çalıştırdığımızda bir mesaj alıyoruz. Bu mesaj bize, uygun bir *binwidth* seçildiğini ve ayrıca 69 adet eksik değer bulunduğunu bildiriyor. Bu bir hata değil, yalnızca **ggplot()** fonksiyonunun size bilgi vermesidir!

### Histogram kutuları (bins)

Eğer histogramın basamaklı (kesikli) yapısı sizi rahatsız ederse, birkaç seçeneğiniz vardır.

-   İlk olarak, **bins** veya **binwidth** argümanlarıyla oynayarak histogramın olabildiğince sürekli görünmesini sağlayacak kutu sayısını bulabilirsiniz.

-   İkinci olarak, bir sonraki bölümde göreceğimiz **yoğunluk grafiği (density plot)** kullanabilirsiniz.

**ggplot2**, varsayılan olarak mantıklı bir *binwidth* seçmeye çalışır; ancak bu seçeneği kendiniz belirleyerek geçersiz kılabilirsiniz. **geom_histogram()** içindeki *bins* ve *binwidth* argümanları, **geom_dotplot()** fonksiyonundaki *dotsize* argümanına benzer şekilde isteğe bağlıdır ve histogramın bir yönünü kontrol eder. Örneğin, *binwidth = 5* seçersek histogram daha düzgün görünür. Alternatif olarak, **geom_histogram()**’ın varsayılanı olan 30 kutu yerine istediğimiz kutu sayısını belirtebiliriz.

```{r}
midiPISA %>% 
ggplot( aes(x = ODOKUMA1  )) +
  geom_histogram(binwidth = 5)
```

```{midiPISA %>%}
ggplot( aes(x = ODOKUMA1  )) +
  geom_histogram(binwidth = 30)
```

```{r}
midiPISA %>% 
ggplot( aes(x = ODOKUMA1  )) +
  geom_histogram(binwidth = 60)
```

## Yoğunluk grafiği (Density plot)

Yoğunluk grafiği, histogramın şeklini **düzgün (smooth) bir çizgiyle** temsil eder. Bunu, histogramın üzerine yumuşatılmış bir çizgi çizmek gibi düşünebilirsiniz; böylece dağılımın genel şeklini daha pürüzsüz bir şekilde gösterir. Ancak yoğunluk grafiği, verideki ani sıçramalara karşı oldukça hassastır, bu yüzden yalnızca **büyük örneklemlerle** kullanılması önerilir.

Kodumuzda değişen tek satır, fonksiyonun **geom_density()** olarak değiştirilmesidir.

```{r}
midiPISA %>% 
ggplot( aes(x = ODOKUMA1  )) +
geom_density()
```

#### Bandwidth (bant genişliği)

Yoğunluk grafiğinin daha düzgün görünmesini istiyorsak, grafiğin **bandwidth** (bant genişliği) değerini artırabiliriz. Bandwidth arttıkça grafik daha pürüzsüz hale gelir; daha küçük bandwidth değerleri ise daha dalgalı (volatil) görünümlere yol açar.

Peki grafiklerimiz için “en iyi” binwidth veya bandwidth değerini nasıl belirleyeceğiz? Genellikle varsayılan ayarlar makuldür; ancak farklı ölçeklerdeki yapıları görebilmek için hem daha pürüzsüz hem de daha ayrıntılı versiyonlarla oynamak iyi bir uygulamadır. Histogramdaki **bins** argümanına benzer şekilde, bandwidth değeri de **geom_density()** fonksiyonunun grafiği oluştururken kullandığı kutu sayısını belirler. Daha büyük bandwidth değerleri daha az kutu üzerinden yumuşatma yapar, bu yüzden daha pürüzsüz bir yoğunluk grafiği elde etmek için **daha büyük bw değerleri** seçebilirsiniz.

Aşağıdaki alıştırmada farklı **bandwidth** değerlerini deneyin.

```{r}
midiPISA %>% 
ggplot( aes(x = ODOKUMA1  )) +
  geom_density(bw = 100)
```

### Kutu grafiği (Boxplot)

Histogram gibi, **kutu grafiği (boxplot)** de ham verileri doğrudan göstermez. Bunun yerine, verilerin özet istatistiklerini görselleştirir. Bir kutu grafiği:

-   Dağılımın merkezini (**medyan**),

-   Verilerin orta yarısını ayıran değerleri (**birinci ve üçüncü çeyrekler**),

-   Verilerin büyük çoğunluğunu gösteren değerleri (**bıyıkların uçları**)

çizer.

Dikkat ederseniz, R kodumuzda değişen tek satır **geom_boxplot()** fonksiyonunun kullanılmasıdır.

```{r}
midiPISA %>% 
ggplot( aes(x = ODOKUMA1  )) +
 geom_boxplot()
```

**Kutu, verilerin merkezi çoğunluğunu (büyük kısmını) temsil eder.**

**Bıyıklar, verilerin neredeyse tamamını kapsar.**

Aykırı (uç) değerler ise noktalarla gösterilir.

## Boxplotlar & Dotplotlar

Bir boxplot’un nasıl oluşturulduğunu daha iyi anlamak için **önce bir dotplot’tan başlayalım**.

Boxplot üç temel özet istatistik etrafında şekillenir:

-   **Birinci çeyrek (Q1):** Verilerin %25’i bu değerin altındadır.

-   **İkinci çeyrek (Q2 / medyan):** Verilerin %50’si bu değerin altındadır. Yani veri setinin tam ortasında yer alır.

-   **Üçüncü çeyrek (Q3):** Verilerin %75’i bu değerin altındadır.

Medyanın ikinci çeyrek olarak adlandırılmasının nedeni, verilerin yarısının (iki çeyreğin) onun altında, yarısının ise üstünde olmasıdır. Benzer şekilde, birinci çeyrek verilerin yalnızca dörtte birini (%25) altına alırken, üçüncü çeyrek verilerin dörtte üçünü (%75) altına alır.

Bu üç sayı, boxplot’taki **kutuyu** oluşturur:

-   Medyan ortada,

-   Q1 ve Q3 ise kutunun kenarlarında yer alır.

Bir boxplot’a baktığınızda **her zaman bilmeniz gereken şey**, verilerin orta yarısının bu kutunun içinde olduğudur.

Kutudan dışarı uzanan çizgilere **“bıyıklar” (whiskers)** denir. Bıyıkların nerede çizileceğine dair çeşitli kurallar vardır. **ggplot2**’nin kullandığı kural şudur:

-   Kutunun uzunluğunu (IQR = Q3 − Q1) 1.5 ile çarpar,

```         
Daha sonra alt ve üst sınırları (fences) şu şekilde belirler:

-    **Alt sınır:** Q1 − 1.5 × IQR

-    **Üst sınır:** Q3 + 1.5 × IQR
```

Bıyıklar, en fazla bu sınırlara kadar uzatılır. Eğer bir gözlem bu sınırların dışında kalıyorsa, **aykırı değer (outlier)** olarak noktalarla gösterilir.

📌 Boxplot’un en pratik özelliklerinden biri de budur: Verilerin büyük kısmından uzak olan değerleri **otomatik olarak işaretleyerek potansiyel aykırı değerleri** tespit etmenize yardımcı olur.

### Yoğunluk grafikleri vs. kutu grafikleri

Kutu grafikleri, özellikle **birden fazla dağılımı aynı anda karşılaştırmanız gerektiğinde** ve **aykırı değerleri tespit etmek istediğinizde** gerçekten çok işe yarar. Ancak zayıf yönlerinden biri, bir dağılımın birden fazla tepe noktası (modu) olup olmadığını gösterememesidir.

Buradaki yoğunluk grafiğini düşünün: iki farklı tepe noktası (iki mod) vardır. Aynı dağılımın kutu grafiğini çizdiğimizde ise bu önemli yapı göz ardı edilir, çünkü kutu grafiği her zaman yalnızca tek bir kutu gösterir.

### Kutu grafikleri ile aykırı değer tespiti

Bir kutu grafiği, dağılımın merkezi ve yayılımını göstermenin yanı sıra, **aykırı değerleri tespit etmenin görsel bir yolunu** da sunar. Örneğin, **msrp (üretici tarafından önerilen satış fiyatı)** değişkenine bu yöntemi uygulayarak, olağanüstü pahalı veya ucuz arabaları tespit edebilirsiniz.

Bunu yapmak için şu adımları izleyelim:

1.  **msrp değişkeninin kutu grafiğini oluşturun.**

2.  En büyük 3–5 aykırı değeri hariç tutarak yeni bir veri seti oluşturun. Bunun için satırları filtreleyip yalnızca **100.000 \$’dan ucuz arabaları** tutarak **cars_no_out** adlı yeni bir veri seti oluşturun.

3.  Bu azaltılmış veri setiyle **msrp’nin yeni kutu grafiğini oluşturun.**

4.  İki grafiği karşılaştırın.

```{r}
# Construct boxplot
midiPISA %>% 
ggplot( aes(x = ODOKUMA1  )) +
  geom_boxplot()

# Exclude outliers from data
midiPISA_no_out <- midiPISA |>
  filter(ODOKUMA1 < 600)
  
# Construct boxplot of msrp using the reduced dataset
ggplot(data = midiPISA_no_out, aes(x = ODOKUMA1)) + 
  geom_boxplot()
```

### İki değişkenin görselleştirilmesi

Eğer yalnızca **tek bir sayısal değişkenin dağılımıyla** ilgileniyorsanız, bunu üç şekilde görebilirsiniz. Birincisi, **marjinal dağılıma** bakmaktır; örneğin okuma puanlarının basit dağılımı gibi.

Ancak, verinin farklı bir alt kümesi için dağılıma bakmak istersek — örneğin yalnızca kızlar için — grafiğe ikinci bir değişken ekleyebiliriz.

İncelediğimiz grafiklere ikinci bir değişkeni dahil etmenin iki ana yolu vardır:

1.  **Facet eklemek** (grafiği alt panellere ayırmak),

2.  **Renk eklemek** (değerleri renklerle ayırt etmek).

```{r}


# Histogram
midiPISA %>% 
  ggplot(aes(x = ODOKUMA1)) +
  geom_histogram(binwidth = 10, fill = "skyblue", color = "white") +
  labs(x = "Okuma Puanı", y = "Frekans",
       title = "Histogram - ODOKUMA1")

# Density Plot
midiPISA %>% 
  ggplot(aes(x = ODOKUMA1)) +
  geom_density(fill = "lightgreen", alpha = 0.5) +
  labs(x = "Okuma Puanı", y = "Yoğunluk",
       title = "Density Plot - ODOKUMA1")

# Boxplot
midiPISA %>% 
  ggplot(aes(y = ODOKUMA1)) +  # Boxplot'ta x yerine y kullanmak daha uygun
  geom_boxplot(fill = "orange", alpha = 0.6) +
  labs(y = "Okuma Puanı",
       title = "Boxplot - ODOKUMA1")

```

### Facet’lenmiş histogramlar

Bir histogram kullanarak otoyol yakıt tüketiminin (highway mileage) dağılımına bakalım, fakat bu kez **araçların pick-up kamyonet olup olmamasına göre ayrı grafikler** çizelim.

Bu ayrı grafikleri oluşturmak için `ggplot()` fonksiyonuna bir **facet_wrap()** katmanı ekleyebiliriz. Facet yapmak istediğimiz değişkeni **facet_wrap()** fonksiyonunun içine yazıyoruz.

```{r}
midiPISA%>% 
  ggplot(aes(x = ODOKUMA1)) +
  geom_histogram(binwidth = 10, fill = "skyblue", color = "white") +
  facet_wrap(~  CINSIYET) +
  labs(x = "Okuma Puanı", y = "Frekans",
       title = "ODOKUMA1 Dağılımı - Cinsiyete Göre Facet")
```

-   `facet_wrap(~ CINS)` ifadesi her cinsiyet için ayrı histogram çiziyor.
-   
-   İsterseniz `~ OKUL_TURU` veya başka kategorik değişkeni de koyabilirsiniz.

Grafiğe bakıldığında, **pick-up olmayan araçların (FALSE değerleri) sayısının pick-up araçlardan (TRUE değerleri) çok daha fazla** olduğu açıkça görülüyor. Grafik ayrıca, **tipik bir pick-up aracın yakıt verimliliğinin (mileage) tipik bir pick-up olmayan araca göre çok daha düşük** olduğunu gösteriyor. Bunun yanında, **pick-up olmayan araçların değişkenliğinin pick-up araçlara göre daha fazla** olduğu da dikkat çekiyor.

### 
